###############################################
# Caddy config for Datamancy
#
# - Official Caddy image + a static Caddyfile (no docker label proxy).
# - Most apps are protected with Authelia via forward_auth where labels
#   previously specified it.
#
# Env vars used inside this file (must be provided to the Caddy container):
# - DOMAIN                     (e.g. example.com)
# - API_LITELLM_ALLOWLIST     (space-separated CIDRs)
# - STACK_ADMIN_EMAIL          (e.g. admin@example.com)
# - ZEROSSL_API_KEY            (optional, for ZeroSSL ACME)
#
# TLS Configuration:
# - Uses ZeroSSL as primary CA (more generous rate limits than Let's Encrypt)
# - Falls back to Let's Encrypt if ZeroSSL fails
# - Development/Testing: Uncomment local_certs for self-signed certificates
###############################################
{
	# DEVELOPMENT: Use self-signed certificates via Caddy's internal CA
	local_certs

	# PRODUCTION: ZeroSSL as primary CA (better rate limits)
	# email {$STACK_ADMIN_EMAIL}

	# ZeroSSL configuration with EAB credentials
	# acme_ca https://acme.zerossl.com/v2/DV90

	# If ZEROSSL_API_KEY is set, use EAB (External Account Binding)
	# This provides better rate limits and reliability
	# Get your API key from: https://app.zerossl.com/developer
	# acme_eab {$ZEROSSL_KID} {$ZEROSSL_HMAC_KEY}

	# Fallback CAs if ZeroSSL fails
	# Note: Let's Encrypt has stricter rate limits (5 certs per exact domain set per week)
	# acme_ca_root https://acme-v02.api.letsencrypt.org/directory
}

# Snippet for Authelia Forward Auth
(authelia_auth) {
	forward_auth authelia:9091 {
		uri /api/authz/forward-auth
		copy_headers Remote-User Remote-Groups Remote-Name Remote-Email
	}
}

# ldap-account-manager
lam.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy ldap-account-manager:80 {
			# Prevent timeout on slow responses
			transport http {
				dial_timeout 5s
				response_header_timeout 30s
			}
		}
	}
}

# Authelia portal
auth.{$DOMAIN} {
	reverse_proxy authelia:9091
}

# Roundcube Webmail - Proxy auth with Dovecot master user
# Also generates certificate for docker-mailserver SMTP/IMAP
mail.{$DOMAIN} {
	import authelia_auth

	reverse_proxy roundcube:80 {
		# Pass authentication headers to Roundcube
		header_up Remote-User {header.Remote-User}
		header_up Remote-Email {header.Remote-Email}
		header_up Remote-Name {header.Remote-Name}
	}
}

# Radicale CalDAV/CardDAV Server
calendar.{$DOMAIN} {
	import authelia_auth

	reverse_proxy radicale:5232 {
		# Pass authentication headers to Radicale
		header_up X-Remote-User {header.Remote-User}
		header_up X-Remote-Email {header.Remote-Email}
	}
}

# Vault Web UI (official HashiCorp UI - protected with forward_auth - admin only)
vault.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy vault:8200
	}
}

# Kopia UI (protected with forward_auth)
kopia.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy kopia:51515
	}
}

# Grafana (protected with forward_auth)
grafana.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy grafana:3000
	}
}

# Open WebUI
open-webui.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy open-webui:8080
	}
}

# Vaultwarden - Protocol-based routing
vaultwarden.{$DOMAIN} {
	# API requests (JSON Accept header) -> app subdomain
	@api header Accept *application/json*
	reverse_proxy @api vaultwarden:80

	# Browser requests -> redirect to app with SSO params
	redir https://app.vaultwarden.{$DOMAIN}/#/sso?identifier={$MAIL_DOMAIN} temporary
}

# Vaultwarden app (OIDC SSO endpoint)
app.vaultwarden.{$DOMAIN} {
	reverse_proxy vaultwarden:80
}

# Planka (uses OIDC)
planka.{$DOMAIN} {
	reverse_proxy planka:1337
}

# BookStack (uses OIDC)
bookstack.{$DOMAIN} {
	reverse_proxy bookstack:80
}

# BookStack API (internal network only - for data-fetcher and search services)
# Bypasses auth for API token authentication
api.bookstack.{$DOMAIN} {
	# Only allow from internal Docker networks
	@notinternal not remote_ip 172.20.0.0/24 172.21.0.0/24 172.22.0.0/24
	respond @notinternal "Access denied: Internal API only" 403

	reverse_proxy bookstack:80
}

# Seafile - Uses remote user authentication with forward_auth
seafile.{$DOMAIN} {
	route {
		forward_auth authelia:9091 {
			uri /api/authz/forward-auth
			copy_headers Remote-User Remote-Groups Remote-Name Remote-Email
		}
		reverse_proxy seafile:80
	}
}

# Seafile API (for API token authentication - bypasses forward_auth)
# API clients authenticate using Seafile API tokens in Authorization header
api.seafile.{$DOMAIN} {
	# Seafile API endpoints
	@api path /api/* /api2/* /seafdav*
	handle @api {
		reverse_proxy seafile:80
	}

	# Return 404 for non-API paths
	respond 404
}

# Matrix (Synapse) - Client-Server API with access token authentication
# Matrix clients authenticate using access tokens, so no forward_auth needed
matrix.{$DOMAIN} {
	reverse_proxy synapse:8008
}

# Matrix API (Server-Server Federation)
# Federation uses Matrix's built-in signature-based authentication
api.matrix.{$DOMAIN} {
	# Federation API endpoint
	@federation path /_matrix/federation/*
	handle @federation {
		reverse_proxy synapse:8008
	}

	# Client-Server API (for programmatic access with access tokens)
	@client path /_matrix/client/*
	handle @client {
		reverse_proxy synapse:8008
	}

	# Media API
	@media path /_matrix/media/*
	handle @media {
		reverse_proxy synapse:8008
	}

	# Admin API (requires Matrix admin access tokens)
	@admin path /_synapse/admin/*
	handle @admin {
		reverse_proxy synapse:8008
	}

	# Return 404 for other paths
	respond 404
}

# Element (Matrix Web Client)
element.{$DOMAIN} {
	reverse_proxy element:80
}

# Mastodon (web)
# With OMNIAUTH_ONLY=true, Mastodon auto-redirects unauthenticated users to OIDC
mastodon.{$DOMAIN} {
	reverse_proxy mastodon-web:3000 {
		# Prevent timeout on slow initial requests
		transport http {
			dial_timeout 10s
			response_header_timeout 30s
		}

		# Ensure proper headers for Rails HostAuthorization
		header_up X-Real-IP {remote_host}
	}
}

# Homepage - apex domain and homepage subdomain
{$DOMAIN}, homepage.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy homepage:3000
	}
}

# Homepage - www redirects to apex
www.{$DOMAIN} {
	redir https://{$DOMAIN}{uri} permanent
}

# JupyterHub - Uses RemoteUserAuthenticator with forward_auth
jupyterhub.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy jupyterhub:8000
	}
}

# Home Assistant - Uses trusted_networks + LDAP auth
# Webhooks must bypass auth
homeassistant.{$DOMAIN} {
	# Webhook paths bypass forward_auth
	@webhooks path /api/webhook/*
	handle @webhooks {
		reverse_proxy homeassistant:8123
	}

	# All other paths use forward_auth
	route {
		import authelia_auth
		reverse_proxy homeassistant:8123 {
			header_up X-Real-IP {remote_host}
		}
	}
}

# Home Assistant API (for programmatic access with long-lived access tokens)
# API clients authenticate using HA long-lived access tokens in Authorization header
api.homeassistant.{$DOMAIN} {
	# API endpoints (bypass forward_auth, rely on HA's token auth)
	@api path /api/*
	handle @api {
		reverse_proxy homeassistant:8123 {
			header_up X-Real-IP {remote_host}
		}
	}

	# Webhooks (no auth required - webhook IDs are secret)
	@webhooks path /api/webhook/*
	handle @webhooks {
		reverse_proxy homeassistant:8123
	}

	# WebSocket API (requires token in connection URL)
	@websocket path /api/websocket
	handle @websocket {
		reverse_proxy homeassistant:8123 {
			header_up X-Real-IP {remote_host}
		}
	}

	# Return 404 for non-API paths
	respond 404
}

# LiteLLM (protected)
litellm.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy litellm:4000
	}
}

# Ntfy (protected)
ntfy.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy ntfy:80
	}
}

# LiteLLM (public API) â€” allowlist by IP, no forward_auth
api.litellm.{$DOMAIN} {
	@notallowed not remote_ip {$API_LITELLM_ALLOWLIST}
	respond @notallowed 403
	reverse_proxy litellm:4000
}

# agent-tool-server - INTERNAL ONLY (not exposed externally)
# Access via: Open WebUI, JupyterHub, or SSH tunnel
# For debugging: ssh -L 8081:agent-tool-server:8081 latium.local

# prompts server (public - serves tool schemas and system prompts)
prompts.{$DOMAIN} {
	# Serve tools.json directly from agent-tool-server
	route /tools.json {
		reverse_proxy agent-tool-server:8081
	}

	# Serve static prompt files from prompt-server
	route {
		reverse_proxy prompt-server:80
	}
}

# ClickHouse HTTP
clickhouse.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy clickhouse:8123
	}
}

# vLLM Router (protected)
vllm-router.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy vllm-router:8010
	}
}

# Forgejo (Git Forge) - with OIDC authentication via Authelia
forgejo.{$DOMAIN} {
	reverse_proxy forgejo:3000
}

# qBittorrent (protected)
qbittorrent.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy qbittorrent:8080 {
			header_up X-Real-IP {remote_host}
		}
	}
}



# Search Indexer (protected - admin only)
search-indexer.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy search-indexer:8096
	}
}

# Search Gateway (protected - all authenticated users)
search.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy search-gateway:8097
	}
}

# Pipeline Monitor (protected - read-only stats dashboard)
pipeline.{$DOMAIN} {
	route {
		import authelia_auth
		reverse_proxy pipeline:8090
	}
}
