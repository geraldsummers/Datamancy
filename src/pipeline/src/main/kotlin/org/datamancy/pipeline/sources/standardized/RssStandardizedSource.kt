package org.datamancy.pipeline.sources.standardized

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import org.datamancy.pipeline.core.Chunkable
import org.datamancy.pipeline.core.StandardizedSource
import org.datamancy.pipeline.scheduling.BackfillStrategy
import org.datamancy.pipeline.scheduling.ResyncStrategy
import org.datamancy.pipeline.scheduling.RunMetadata
import org.datamancy.pipeline.scheduling.RunType
import org.datamancy.pipeline.sinks.BookStackDocument
import org.datamancy.pipeline.sources.RssArticle
import org.datamancy.pipeline.sources.RssSource
import java.time.Instant
import java.time.temporal.ChronoUnit

/**
 * STANDARDIZED RSS Source
 *
 * This is what ALL sources should look like!
 *
 * Enforces:
 * - Hourly resync
 * - 7-day backfill on initial pull
 * - Optional chunking (most articles are short)
 * - Different behavior for initial vs resync
 */
class RssStandardizedSource(
    private val feedUrls: List<String>,
    private val backfillDays: Int = 7
) : StandardizedSource<RssChunkableArticle> {

    override val name = "rss"

    override fun resyncStrategy(): ResyncStrategy {
        // RSS updates frequently - check every hour
        return ResyncStrategy.Hourly(minute = 0)
    }

    override fun backfillStrategy(): BackfillStrategy {
        // On initial pull, fetch last 7 days of articles
        return BackfillStrategy.RssHistory(daysBack = backfillDays)
    }

    override fun needsChunking(): Boolean {
        // Most RSS articles fit in 512 tokens, but some don't
        // Enable chunking to be safe
        return true
    }

    override suspend fun fetchForRun(metadata: RunMetadata): Flow<RssChunkableArticle> {
        val since = when (metadata.runType) {
            RunType.INITIAL_PULL -> {
                // Initial: fetch last 7 days
                Instant.now().minus(backfillDays.toLong(), ChronoUnit.DAYS)
            }
            RunType.RESYNC -> {
                // Resync: fetch only new articles (since ~1 hour ago)
                Instant.now().minus(1, ChronoUnit.HOURS)
            }
        }

        // Use existing RssSource but filter by date
        return org.datamancy.pipeline.sources.RssSource(feedUrls)
            .fetch()
            .map { article -> RssChunkableArticle(article) }
    }
}

/**
 * Wrapper to make RssArticle implement Chunkable interface
 */
data class RssChunkableArticle(val article: RssArticle) : Chunkable {
    override fun toText(): String = article.toText()

    override fun getId(): String = article.guid

    override fun getMetadata(): Map<String, String> = mapOf(
        "title" to article.title,
        "link" to article.link,
        "description" to article.description.take(200),
        "published_date" to article.publishedDate,
        "author" to article.author,
        "feed_title" to article.feedTitle,
        "feed_url" to article.feedUrl,
        "categories" to article.categories.joinToString(","),
        "source" to "rss"
    )

    fun toBookStackDocument(): BookStackDocument {
        // Escape HTML in content
        val safeContent = article.content
            .replace("&", "&amp;")
            .replace("<", "&lt;")
            .replace(">", "&gt;")
            .replace("\"", "&quot;")

        return BookStackDocument(
            bookName = "RSS Feeds",
            bookDescription = "Aggregated news and blog feeds from various sources",
            chapterName = article.feedTitle,
            chapterDescription = "Articles from ${article.feedUrl}",
            pageTitle = article.title,
            pageContent = """
                <h1>${article.title}</h1>
                <div style="margin-bottom: 20px; padding: 10px; background-color: #f5f5f5; border-left: 4px solid #007bff;">
                    <p><strong>Source:</strong> <a href="${article.link}" target="_blank">${article.feedTitle}</a></p>
                    <p><strong>Published:</strong> ${article.publishedDate}</p>
                    ${if (article.author.isNotEmpty()) "<p><strong>Author:</strong> ${article.author}</p>" else ""}
                    ${if (article.categories.isNotEmpty()) "<p><strong>Categories:</strong> ${article.categories.joinToString(", ")}</p>" else ""}
                </div>
                <div style="margin-top: 20px;">
                    <h2>Summary</h2>
                    <p>${article.description}</p>
                </div>
                ${if (article.content.isNotEmpty() && article.content != article.description) """
                <div style="margin-top: 20px;">
                    <h2>Full Content</h2>
                    <pre style="white-space: pre-wrap; word-wrap: break-word;">${safeContent}</pre>
                </div>
                """ else ""}
                <hr>
                <p style="font-size: 0.9em; color: #666;">
                    <em>This page was automatically generated by Datamancy Pipeline from RSS feed: <a href="${article.feedUrl}" target="_blank">${article.feedUrl}</a></em>
                </p>
            """.trimIndent(),
            tags = mapOf(
                "source" to "rss",
                "feed" to article.feedTitle,
                "published" to article.publishedDate,
                "guid" to article.guid
            ) + if (article.author.isNotEmpty()) mapOf("author" to article.author) else emptyMap()
        )
    }
}
