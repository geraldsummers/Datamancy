<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Container Topology - Datamancy Lab</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }
        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #1e1e2e 0%, #2a2a3e 100%);
            color: white;
            min-height: 100vh;
            overflow: hidden;
        }
        .header {
            padding: 1rem 2rem;
            background: rgba(0,0,0,0.3);
            display: flex;
            justify-content: space-between;
            align-items: center;
            box-shadow: 0 2px 10px rgba(0,0,0,0.3);
        }
        .header h1 {
            font-size: 1.5rem;
        }
        .header a {
            color: #667eea;
            text-decoration: none;
            padding: 0.5rem 1rem;
            border-radius: 6px;
            background: rgba(102, 126, 234, 0.1);
            transition: all 0.2s;
        }
        .header a:hover {
            background: rgba(102, 126, 234, 0.2);
        }
        #graph {
            width: 100%;
            height: calc(100vh - 80px);
        }
        .node {
            cursor: pointer;
        }
        .node circle {
            stroke-width: 2px;
        }
        .node.running circle {
            fill: #4ade80;
            stroke: #22c55e;
        }
        .node.stopped circle {
            fill: #ef4444;
            stroke: #dc2626;
        }
        .node.paused circle {
            fill: #fbbf24;
            stroke: #f59e0b;
        }
        .node.restarting circle {
            fill: #60a5fa;
            stroke: #3b82f6;
        }
        .node text {
            fill: white;
            font-size: 12px;
            font-weight: 500;
            text-anchor: middle;
            pointer-events: none;
            text-shadow: 0 1px 3px rgba(0,0,0,0.8);
        }
        .link {
            stroke: rgba(102, 126, 234, 0.4);
            stroke-width: 2px;
            fill: none;
        }
        .link.database {
            stroke: rgba(236, 72, 153, 0.4);
            stroke-dasharray: 5,5;
        }
        .link.proxy {
            stroke: rgba(34, 197, 94, 0.4);
        }
        .link.storage {
            stroke: rgba(249, 115, 22, 0.4);
            stroke-dasharray: 3,3;
        }
        .tooltip {
            position: absolute;
            padding: 10px;
            background: rgba(0,0,0,0.9);
            border: 1px solid #667eea;
            border-radius: 6px;
            pointer-events: none;
            opacity: 0;
            transition: opacity 0.2s;
            max-width: 300px;
            font-size: 12px;
            z-index: 1000;
        }
        .legend {
            position: absolute;
            top: 100px;
            right: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(102, 126, 234, 0.3);
        }
        .legend-item {
            display: flex;
            align-items: center;
            margin: 5px 0;
            font-size: 12px;
        }
        .legend-circle {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
        }
        .legend-line {
            width: 20px;
            height: 2px;
            margin-right: 8px;
        }
        .stats {
            position: absolute;
            top: 100px;
            left: 20px;
            background: rgba(0,0,0,0.7);
            padding: 15px;
            border-radius: 8px;
            border: 1px solid rgba(102, 126, 234, 0.3);
            min-width: 200px;
        }
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 5px 0;
            font-size: 12px;
        }
        .stat-value {
            font-weight: bold;
            margin-left: 10px;
        }
        .loading {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            font-size: 1.5rem;
            color: #667eea;
        }
    </style>
</head>
<body>
    <div class="header">
        <h1>üîÆ Container Topology</h1>
        <a href="/">‚Üê Back to Dashboard</a>
    </div>

    <div class="loading" id="loading">Loading container data...</div>

    <div class="stats" id="stats" style="display: none;">
        <h3 style="margin-bottom: 10px;">Statistics</h3>
        <div class="stat-item">
            <span>Total Containers:</span>
            <span class="stat-value" id="stat-total">0</span>
        </div>
        <div class="stat-item">
            <span>Running:</span>
            <span class="stat-value" style="color: #4ade80;" id="stat-running">0</span>
        </div>
        <div class="stat-item">
            <span>Stopped:</span>
            <span class="stat-value" style="color: #ef4444;" id="stat-stopped">0</span>
        </div>
        <div class="stat-item">
            <span>Networks:</span>
            <span class="stat-value" id="stat-networks">0</span>
        </div>
    </div>

    <div class="legend">
        <h3 style="margin-bottom: 10px;">Legend</h3>
        <div class="legend-item">
            <div class="legend-circle" style="background: #4ade80;"></div>
            <span>Running</span>
        </div>
        <div class="legend-item">
            <div class="legend-circle" style="background: #ef4444;"></div>
            <span>Stopped</span>
        </div>
        <div class="legend-item">
            <div class="legend-circle" style="background: #fbbf24;"></div>
            <span>Paused</span>
        </div>
        <div class="legend-item">
            <div class="legend-circle" style="background: #60a5fa;"></div>
            <span>Restarting</span>
        </div>
        <hr style="margin: 10px 0; border-color: rgba(102, 126, 234, 0.3);">
        <div class="legend-item">
            <div class="legend-line" style="background: rgba(102, 126, 234, 0.6);"></div>
            <span>Network</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: rgba(236, 72, 153, 0.6); height: 2px;"></div>
            <span>Database</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: rgba(34, 197, 94, 0.6);"></div>
            <span>Proxy</span>
        </div>
        <div class="legend-item">
            <div class="legend-line" style="background: rgba(249, 115, 22, 0.6);"></div>
            <span>Storage</span>
        </div>
    </div>

    <svg id="graph"></svg>
    <div class="tooltip" id="tooltip"></div>

    <script>
        // Setup SVG
        const width = window.innerWidth;
        const height = window.innerHeight - 80;
        const svg = d3.select('#graph')
            .attr('width', width)
            .attr('height', height);

        const g = svg.append('g');

        // Zoom behavior
        const zoom = d3.zoom()
            .scaleExtent([0.1, 4])
            .on('zoom', (event) => {
                g.attr('transform', event.transform);
            });

        svg.call(zoom);

        // Process data
        function processData(data) {
            const nodes = data.containers.map(c => ({
                id: c.name,
                status: c.status,
                type: c.type,
                connections: c.connections
            }));

            const links = [];
            data.containers.forEach(c => {
                c.connections.forEach(target => {
                    const targetNode = nodes.find(n => n.id === target);
                    if (targetNode) {
                        links.push({
                            source: c.name,
                            target: target,
                            type: targetNode.type
                        });
                    }
                });
            });

            return { nodes, links };
        }

        // Create visualization
        function createVisualization(data) {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('stats').style.display = 'block';

            const { nodes, links } = processData(data);

            // Update stats
            document.getElementById('stat-total').textContent = nodes.length;
            document.getElementById('stat-running').textContent = nodes.filter(n => n.status === 'running').length;
            document.getElementById('stat-stopped').textContent = nodes.filter(n => n.status === 'stopped').length;
            document.getElementById('stat-networks').textContent = new Set(links.map(l => l.type)).size;

            // Force simulation
            const simulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(150))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(50));

            // Draw links
            const link = g.append('g')
                .selectAll('path')
                .data(links)
                .enter()
                .append('path')
                .attr('class', d => `link ${d.type}`)
                .attr('marker-end', 'url(#arrow)');

            // Arrow marker
            svg.append('defs').append('marker')
                .attr('id', 'arrow')
                .attr('viewBox', '0 -5 10 10')
                .attr('refX', 25)
                .attr('refY', 0)
                .attr('markerWidth', 6)
                .attr('markerHeight', 6)
                .attr('orient', 'auto')
                .append('path')
                .attr('d', 'M0,-5L10,0L0,5')
                .attr('fill', 'rgba(102, 126, 234, 0.6)');

            // Draw nodes
            const node = g.append('g')
                .selectAll('g')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', d => `node ${d.status}`)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            node.append('circle')
                .attr('r', d => d.type === 'storage' ? 8 : 20);

            node.append('text')
                .attr('dy', d => d.type === 'storage' ? 15 : 30)
                .text(d => d.id);

            // Tooltip
            const tooltip = d3.select('#tooltip');

            node.on('mouseenter', function(event, d) {
                tooltip
                    .style('opacity', 1)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY + 10) + 'px')
                    .html(`
                        <strong>${d.id}</strong><br>
                        Status: <span style="color: ${d.status === 'running' ? '#4ade80' : '#ef4444'}">${d.status}</span><br>
                        Type: ${d.type}<br>
                        Connections: ${d.connections.length}
                    `);
            })
            .on('mouseleave', function() {
                tooltip.style('opacity', 0);
            });

            // Update positions
            simulation.on('tick', () => {
                link.attr('d', d => {
                    const dx = d.target.x - d.source.x;
                    const dy = d.target.y - d.source.y;
                    return `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
                });

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) simulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) simulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        // WebSocket connection for real-time updates
        let ws = null;
        let reconnectInterval = null;
        let currentData = null;
        let currentSimulation = null;

        function connectWebSocket() {
            const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
            const wsUrl = `${protocol}//topology-api.${window.location.hostname}`;

            console.log('Connecting to WebSocket:', wsUrl);
            document.getElementById('loading').textContent = 'Connecting to live data stream...';

            ws = new WebSocket(wsUrl);

            ws.onopen = () => {
                console.log('WebSocket connected');
                document.getElementById('loading').textContent = 'Loading container data...';

                // Clear reconnect interval if exists
                if (reconnectInterval) {
                    clearInterval(reconnectInterval);
                    reconnectInterval = null;
                }
            };

            ws.onmessage = (event) => {
                try {
                    const message = JSON.parse(event.data);
                    console.log('Received message:', message.type);

                    if (message.type === 'topology_initial' || message.type === 'topology_update') {
                        currentData = message.data;

                        if (message.event) {
                            console.log(`Container event: ${message.event.action} - ${message.event.container}`);
                            showNotification(message.event);
                        }

                        updateVisualization(currentData);
                    }
                } catch (error) {
                    console.error('Error parsing WebSocket message:', error);
                }
            };

            ws.onerror = (error) => {
                console.error('WebSocket error:', error);
                document.getElementById('loading').textContent = 'Connection error, retrying...';
            };

            ws.onclose = () => {
                console.log('WebSocket disconnected');
                document.getElementById('loading').style.display = 'block';
                document.getElementById('loading').textContent = 'Disconnected, reconnecting...';

                // Attempt to reconnect every 3 seconds
                if (!reconnectInterval) {
                    reconnectInterval = setInterval(() => {
                        console.log('Attempting to reconnect...');
                        connectWebSocket();
                    }, 3000);
                }
            };
        }

        // Show notification for container events
        function showNotification(event) {
            const notification = document.createElement('div');
            notification.style.cssText = `
                position: fixed;
                top: 20px;
                right: 20px;
                background: rgba(0,0,0,0.9);
                color: white;
                padding: 15px 20px;
                border-radius: 8px;
                border-left: 4px solid ${event.action === 'start' ? '#4ade80' : '#ef4444'};
                box-shadow: 0 4px 12px rgba(0,0,0,0.5);
                z-index: 10000;
                animation: slideIn 0.3s ease;
            `;
            notification.innerHTML = `
                <strong>${event.action.toUpperCase()}</strong><br>
                <small>${event.container}</small>
            `;

            document.body.appendChild(notification);

            setTimeout(() => {
                notification.style.animation = 'slideOut 0.3s ease';
                setTimeout(() => notification.remove(), 300);
            }, 3000);
        }

        // Update visualization with new data
        function updateVisualization(data) {
            // Clear existing visualization
            g.selectAll('*').remove();

            document.getElementById('loading').style.display = 'none';
            document.getElementById('stats').style.display = 'block';

            const { nodes, links } = processData(data);

            // Update stats
            document.getElementById('stat-total').textContent = nodes.length;
            document.getElementById('stat-running').textContent = nodes.filter(n => n.status === 'running').length;
            document.getElementById('stat-stopped').textContent = nodes.filter(n => n.status === 'stopped').length;
            document.getElementById('stat-networks').textContent = data.networks?.length || 0;

            // Force simulation
            currentSimulation = d3.forceSimulation(nodes)
                .force('link', d3.forceLink(links).id(d => d.id).distance(150))
                .force('charge', d3.forceManyBody().strength(-300))
                .force('center', d3.forceCenter(width / 2, height / 2))
                .force('collision', d3.forceCollide().radius(50));

            // Arrow marker
            if (!svg.select('#arrow').node()) {
                svg.append('defs').append('marker')
                    .attr('id', 'arrow')
                    .attr('viewBox', '0 -5 10 10')
                    .attr('refX', 25)
                    .attr('refY', 0)
                    .attr('markerWidth', 6)
                    .attr('markerHeight', 6)
                    .attr('orient', 'auto')
                    .append('path')
                    .attr('d', 'M0,-5L10,0L0,5')
                    .attr('fill', 'rgba(102, 126, 234, 0.6)');
            }

            // Draw links
            const link = g.append('g')
                .selectAll('path')
                .data(links)
                .enter()
                .append('path')
                .attr('class', d => `link ${d.type}`)
                .attr('marker-end', 'url(#arrow)');

            // Draw nodes
            const node = g.append('g')
                .selectAll('g')
                .data(nodes)
                .enter()
                .append('g')
                .attr('class', d => `node ${d.status}`)
                .call(d3.drag()
                    .on('start', dragstarted)
                    .on('drag', dragged)
                    .on('end', dragended));

            node.append('circle')
                .attr('r', d => d.type === 'storage' ? 8 : 20);

            node.append('text')
                .attr('dy', d => d.type === 'storage' ? 15 : 30)
                .text(d => d.id);

            // Tooltip
            const tooltip = d3.select('#tooltip');

            node.on('mouseenter', function(event, d) {
                tooltip
                    .style('opacity', 1)
                    .style('left', (event.pageX + 10) + 'px')
                    .style('top', (event.pageY + 10) + 'px')
                    .html(`
                        <strong>${d.id}</strong><br>
                        Status: <span style="color: ${d.status === 'running' ? '#4ade80' : '#ef4444'}">${d.status}</span><br>
                        Type: ${d.type}<br>
                        Connections: ${d.connections.length}
                    `);
            })
            .on('mouseleave', function() {
                tooltip.style('opacity', 0);
            });

            // Update positions
            currentSimulation.on('tick', () => {
                link.attr('d', d => {
                    return `M${d.source.x},${d.source.y}L${d.target.x},${d.target.y}`;
                });

                node.attr('transform', d => `translate(${d.x},${d.y})`);
            });

            // Drag functions
            function dragstarted(event, d) {
                if (!event.active) currentSimulation.alphaTarget(0.3).restart();
                d.fx = d.x;
                d.fy = d.y;
            }

            function dragged(event, d) {
                d.fx = event.x;
                d.fy = event.y;
            }

            function dragended(event, d) {
                if (!event.active) currentSimulation.alphaTarget(0);
                d.fx = null;
                d.fy = null;
            }
        }

        // Add CSS for notifications
        const style = document.createElement('style');
        style.textContent = `
            @keyframes slideIn {
                from { transform: translateX(400px); opacity: 0; }
                to { transform: translateX(0); opacity: 1; }
            }
            @keyframes slideOut {
                from { transform: translateX(0); opacity: 1; }
                to { transform: translateX(400px); opacity: 0; }
            }
        `;
        document.head.appendChild(style);

        // Start WebSocket connection
        connectWebSocket();

        // Cleanup on page unload
        window.addEventListener('beforeunload', () => {
            if (ws) {
                ws.close();
            }
        });
    </script>
</body>
</html>
