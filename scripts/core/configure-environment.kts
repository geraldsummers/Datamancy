#!/usr/bin/env kotlin
//
// Kotlin rewrite of scripts/init-secrets.sh
// Provides the same commands: init | export | rotate SECRET_NAME
// Uses openssl for crypto, preserving wire-format compatibility.

@file:Suppress("SameParameterValue")

import java.io.File
import java.nio.charset.StandardCharsets
import java.nio.file.Files
import java.nio.file.Path
import java.nio.file.attribute.PosixFilePermission
import java.security.SecureRandom
import java.util.Base64

// ---------- Logging ----------
private val RED = "\u001B[0;31m"
private val GREEN = "\u001B[0;32m"
private val YELLOW = "\u001B[1;33m"
private val NC = "\u001B[0m"

private fun logInfo(msg: String) = println("${GREEN}[INFO]${NC} $msg")
private fun logWarn(msg: String) = println("${YELLOW}[WARN]${NC} $msg")
private fun logError(msg: String) {
    System.err.println("${RED}[ERROR]${NC} $msg")
}

// ---------- Environment & Paths ----------
private val env = System.getenv()
private val SECRETS_DIR: Path = Path.of(env["SECRETS_DIR"] ?: "\$HOME/.local/share/stack-secrets")
private val SECRETS_FILE: Path = SECRETS_DIR.resolve("stack_secrets.enc")
private val SECRETS_KEY_FILE: Path = SECRETS_DIR.resolve(".key")

// ---------- Non-sensitive stack configuration (easily changeable) ----------
// These values are exported in plain text at the TOP of the generated .env file by the `export` command.
// You can override them by setting the corresponding environment variables when running the script.
private val VOLUMES_ROOT: String = env["VOLUMES_ROOT"] ?: "./volumes"
private val DOMAIN: String = env["DOMAIN"] ?: "project-saturn.com"
private val STACK_ADMIN_EMAIL_CFG: String = env["STACK_ADMIN_EMAIL"] ?: "admin@project-saturn.com"
private val MAIL_DOMAIN: String = env["MAIL_DOMAIN"] ?: DOMAIN
private val VECTOR_EMBED_SIZE: String = env["VECTOR_EMBED_SIZE"] ?: "384"
private val QDRANT_URL: String = env["QDRANT_URL"] ?: "http://qdrant:6333"
private val EMBED_MODEL: String = env["EMBED_MODEL"] ?: "embed-small"
// OpenAI-compatible gateway (LiteLLM) base URL used by internal services (e.g., Benthos)
private val LITELLM_URL: String = env["LITELLM_URL"] ?: "http://litellm:4000/v1"

private fun buildConfigHeader(): String = buildString {
    appendLine("###############################################")
    appendLine("# Datamancy Stack - Environment Configuration")
    appendLine("#")
    appendLine("# SECURITY: This file should only contain non-sensitive configuration.")
    appendLine("# All secrets are auto-generated by the secrets-manager service.")
    appendLine("###############################################")
    appendLine()
    appendLine("# Host volumes root (non-sensitive)")
    appendLine("# All docker volumes will be mounted under this host directory.")
    appendLine("# Change to an absolute path if desired (e.g. /data/datamancy)")
    appendLine("VOLUMES_ROOT=$VOLUMES_ROOT")
    appendLine()
    appendLine("# Domain configuration")
    appendLine("DOMAIN=$DOMAIN")
    appendLine()
    appendLine("# Admin email (non-sensitive)")
    appendLine("STACK_ADMIN_EMAIL=$STACK_ADMIN_EMAIL_CFG")
    appendLine()
    appendLine("# Mail domain configuration")
    appendLine("MAIL_DOMAIN=$MAIL_DOMAIN")
    appendLine()
    appendLine("# External API tokens (provide these via environment variables at runtime if needed)")
    appendLine("# HUGGINGFACEHUB_API_TOKEN=<set-via-environment>")
    appendLine()
    appendLine("# Vector database configuration")
    appendLine("VECTOR_EMBED_SIZE=$VECTOR_EMBED_SIZE")
    appendLine("QDRANT_URL=$QDRANT_URL")
    appendLine()
    appendLine("# LLM configuration")
    appendLine("EMBED_MODEL=$EMBED_MODEL")
    appendLine("# OpenAI-compatible gateway (LiteLLM) base URL used by internal services (e.g., Benthos)")
    appendLine("LITELLM_URL=$LITELLM_URL")
    appendLine()
}

// ---------- Utilities ----------
private fun runCommand(vararg cmd: String, input: ByteArray? = null): String {
    val pb = ProcessBuilder(*cmd)
    pb.redirectError(ProcessBuilder.Redirect.INHERIT)
    val p = pb.start()
    if (input != null) {
        p.outputStream.use { it.write(input); it.flush() }
    } else {
        p.outputStream.close()
    }
    val out = p.inputStream.readBytes()
    val code = p.waitFor()
    if (code != 0) throw RuntimeException("Command failed (${cmd.joinToString(" ")}), exit=$code")
    return out.toString(StandardCharsets.UTF_8)
}

private fun setPerm600(path: Path) {
    try {
        Files.setPosixFilePermissions(path, setOf(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE))
    } catch (_: UnsupportedOperationException) {
        // Non-POSIX FS (Windows) — ignore
    }
}

private fun setPerm700(path: Path) {
    try {
        Files.setPosixFilePermissions(path, setOf(PosixFilePermission.OWNER_READ, PosixFilePermission.OWNER_WRITE, PosixFilePermission.OWNER_EXECUTE))
    } catch (_: UnsupportedOperationException) {
        // Non-POSIX FS — ignore
    }
}

private val rng = SecureRandom()

// ---------- Secret Generators (mirroring bash behaviors) ----------
private fun generateSecretHex(length: Int = 32): String {
    // openssl rand -hex N -> produces 2N hex chars because N bytes requested; bash passed 32 meaning 32 bytes -> 64 hex chars
    // We call openssl to match format exactly.
    val s = runCommand("openssl", "rand", "-hex", length.toString())
    return s.trim()
}

private fun generateSecretB64(length: Int = 32): String {
    // openssl rand -base64 N; we then strip newlines
    val s = runCommand("openssl", "rand", "-base64", length.toString())
    return s.replace("\n", "").trim()
}

private fun generateRsaKeyBase64(): String {
    // Equivalent to: openssl genrsa 4096 | base64 -w 0
    // Keep standard Base64 padding to match `base64` CLI output
    val pem = runCommand("openssl", "genrsa", "4096").trim()
    return Base64.getEncoder().encodeToString(pem.toByteArray(StandardCharsets.UTF_8))
}

// Avoid '$' since docker compose treats $VAR as interpolation in .env values if not escaped
// Avoid URL-special characters (#%&@!*) to prevent issues with database connection strings
private val PASSWORD_CHARS = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789-_+=.,:"
private fun generatePassword(length: Int = 24): String {
    val sb = StringBuilder(length)
    for (i in 0 until length) {
        val idx = rng.nextInt(PASSWORD_CHARS.length)
        sb.append(PASSWORD_CHARS[idx])
    }
    return sb.toString()
}

private fun urlEncode(value: String): String {
    return java.net.URLEncoder.encode(value, "UTF-8")
}

// ---------- Encryption Helpers (via openssl) ----------
private fun ensureKeyFile() {
    if (!Files.exists(SECRETS_KEY_FILE)) {
        val hex = generateSecretHex(32) // 32 bytes -> 64 hex chars
        Files.writeString(SECRETS_KEY_FILE, hex + "\n", StandardCharsets.UTF_8)
        setPerm600(SECRETS_KEY_FILE)
    }
}

private fun encryptSecrets(plain: String) {
    ensureKeyFile()
    // write to temp file to avoid exposing in args
    val tmp = Files.createTempFile("stack_secrets", ".tmp")
    try {
        Files.writeString(tmp, plain, StandardCharsets.UTF_8)
        setPerm600(tmp)
        runCommand(
            "openssl", "enc", "-aes-256-cbc", "-salt", "-pbkdf2",
            "-in", tmp.toString(),
            "-out", SECRETS_FILE.toString(),
            "-pass", "file:${SECRETS_KEY_FILE}"
        )
        setPerm600(SECRETS_FILE)
    } finally {
        try { Files.deleteIfExists(tmp) } catch (_: Exception) {}
    }
}

private fun decryptSecrets(): String {
    if (!Files.exists(SECRETS_FILE) || !Files.exists(SECRETS_KEY_FILE)) {
        throw IllegalStateException("Secrets or key file missing")
    }
    return runCommand(
        "openssl", "enc", "-aes-256-cbc", "-d", "-pbkdf2",
        "-in", SECRETS_FILE.toString(),
        "-pass", "file:${SECRETS_KEY_FILE}"
    )
}

// ---------- Commands ----------
private fun cmdInit() {
    Files.createDirectories(SECRETS_DIR)
    setPerm700(SECRETS_DIR)

    if (Files.exists(SECRETS_FILE)) {
        logError("Secrets already initialized. Use 'rotate' to change specific secrets.")
        kotlin.system.exitProcess(1)
    }

    logInfo("Generating cryptographically secure secrets...")

    val now = java.time.ZonedDateTime.now(java.time.ZoneOffset.UTC).format(java.time.format.DateTimeFormatter.ofPattern("yyyy-MM-dd'T'HH:mm:ss'Z'"))

    val content = buildString {
        appendLine("# Datamancy Stack Secrets")
        appendLine("# Generated at: $now")
        appendLine("# WARNING: This file is encrypted. Do not edit manually.")
        appendLine()

        // Stack admin credentials
        appendLine("STACK_ADMIN_USER=admin")
        appendLine("STACK_ADMIN_PASSWORD=${generatePassword(32)}")
        appendLine()

        // Authelia secrets
        appendLine("AUTHELIA_JWT_SECRET=${generateSecretHex(32)}")
        appendLine("AUTHELIA_SESSION_SECRET=${generateSecretHex(32)}")
        appendLine("AUTHELIA_STORAGE_ENCRYPTION_KEY=${generateSecretHex(32)}")
        appendLine("AUTHELIA_OIDC_HMAC_SECRET=${generateSecretHex(32)}")
        val rsaKeyB64 = generateRsaKeyBase64()
        appendLine("AUTHELIA_IDENTITY_PROVIDERS_OIDC_ISSUER_PRIVATE_KEY=$rsaKeyB64")
        // Decode for template processing (multi-line YAML value)
        val rsaKeyPem = String(Base64.getDecoder().decode(rsaKeyB64), StandardCharsets.UTF_8)
        // Don't add extra indentation - YAML literal block (|) handles it
        appendLine("OIDC_PRIVATE_KEY=\"${rsaKeyPem.trim()}\"")
        appendLine()

        // OAuth client secrets
        appendLine("GRAFANA_OAUTH_SECRET=${generateSecretHex(32)}")
        appendLine("VAULTWARDEN_OAUTH_SECRET=${generateSecretHex(32)}")
        appendLine("PLANKA_OAUTH_SECRET=${generateSecretHex(32)}")
        appendLine("JUPYTERHUB_OAUTH_SECRET=${generateSecretHex(32)}")
        appendLine("LITELLM_OAUTH_SECRET=${generateSecretHex(32)}")
        appendLine("OPENWEBUI_OAUTH_SECRET=${generateSecretHex(32)}")
        appendLine("PGADMIN_OAUTH_SECRET=${generateSecretHex(32)}")
        appendLine("PORTAINER_OAUTH_SECRET=${generateSecretHex(32)}")
        appendLine("NEXTCLOUD_OIDC_SECRET=${generateSecretHex(32)}")
        appendLine("HOMEASSISTANT_OAUTH_SECRET=${generateSecretHex(32)}")
        appendLine("DIM_OAUTH_SECRET=${generateSecretHex(32)}")
        appendLine()

        // OIDC client secret hashes for Authelia (generated by separate script)
        appendLine("# OIDC hashes - run: kotlin scripts/security/generate-oidc-hashes.main.kts")
        appendLine("GRAFANA_OAUTH_SECRET_HASH=PENDING")
        appendLine("VAULTWARDEN_OAUTH_SECRET_HASH=PENDING")
        appendLine("PLANKA_OAUTH_SECRET_HASH=PENDING")
        appendLine("JUPYTERHUB_OAUTH_SECRET_HASH=PENDING")
        appendLine("OPENWEBUI_OAUTH_SECRET_HASH=PENDING")
        appendLine("PGADMIN_OAUTH_SECRET_HASH=PENDING")
        appendLine("NEXTCLOUD_OAUTH_SECRET_HASH=PENDING")
        appendLine("HOMEASSISTANT_OAUTH_SECRET_HASH=PENDING")
        appendLine("DIM_OAUTH_SECRET_HASH=PENDING")
        appendLine("MASTODON_OAUTH_SECRET_HASH=PENDING")
        appendLine()

        // Application secrets
        appendLine("PLANKA_SECRET_KEY=${generateSecretHex(32)}")
        appendLine("ONLYOFFICE_JWT_SECRET=${generateSecretHex(32)}")
        appendLine("VAULTWARDEN_ADMIN_TOKEN=${generateSecretB64(32)}")
        appendLine("VAULTWARDEN_SMTP_PASSWORD=${generatePassword(24)}")
        appendLine("BOOKSTACK_APP_KEY=base64:${generateSecretB64(32)}")
        appendLine()

        // Mastodon secrets (to satisfy compose env and app config)
        // Notes:
        // - SECRET_KEY_BASE and OTP_SECRET are just long random secrets; hex format is acceptable
        // - SMTP user defaults to a service account at MAIL_DOMAIN; override via env if needed
        // - VAPID keys here are random base64 strings as placeholders; for production you may wish
        //   to replace them with keys generated by Mastodon rake tasks, but these avoid empty vars.
        val mastodonSmtpUser = env["MASTODON_SMTP_USER"] ?: "mastodon@${MAIL_DOMAIN}"
        appendLine("MASTODON_DB_PASSWORD=${generatePassword(32)}")
        appendLine("MASTODON_SECRET_KEY_BASE=${generateSecretHex(64)}")
        appendLine("MASTODON_OTP_SECRET=${generateSecretHex(64)}")
        appendLine("MASTODON_ENCRYPTION_DETERMINISTIC_KEY=${generateSecretHex(32)}")
        appendLine("MASTODON_ENCRYPTION_KEY_DERIVATION_SALT=${generateSecretHex(32)}")
        appendLine("MASTODON_ENCRYPTION_PRIMARY_KEY=${generateSecretHex(32)}")
        appendLine("MASTODON_SMTP_USER=${mastodonSmtpUser}")
        appendLine("MASTODON_SMTP_PASSWORD=${generatePassword(24)}")
        appendLine("MASTODON_OIDC_SECRET=${generateSecretHex(48)}")
        appendLine("VAPID_PRIVATE_KEY=${generateSecretB64(64)}")
        appendLine("VAPID_PUBLIC_KEY=${generateSecretB64(64)}")
        appendLine()

        // Database passwords
        appendLine("PLANKA_DB_PASSWORD=${generatePassword(32)}")
        // BookStack database password for MariaDB
        appendLine("BOOKSTACK_DB_PASSWORD=${generatePassword(32)}")
        appendLine("SYNAPSE_DB_PASSWORD=${generatePassword(32)}")
        appendLine("MAILU_DB_PASSWORD=${generatePassword(32)}")
        appendLine("AUTHELIA_DB_PASSWORD=${generatePassword(32)}")
        appendLine("GRAFANA_DB_PASSWORD=${generatePassword(32)}")
        appendLine("VAULTWARDEN_DB_PASSWORD=${generatePassword(32)}")
        val openwebuiPassword = generatePassword(32)
        appendLine("OPENWEBUI_DB_PASSWORD=$openwebuiPassword")
        appendLine("OPENWEBUI_DB_PASSWORD_ENCODED=${urlEncode(openwebuiPassword)}")
        appendLine("MARIADB_SEAFILE_ROOT_PASSWORD=${generatePassword(32)}")
        appendLine("MARIADB_SEAFILE_PASSWORD=${generatePassword(32)}")
        appendLine("SEAFILE_JWT_KEY=${generateSecretHex(32)}")
        appendLine()

        // Synapse Matrix secrets
        appendLine("SYNAPSE_REGISTRATION_SECRET=${generateSecretHex(32)}")
        appendLine("SYNAPSE_MACAROON_SECRET=${generateSecretHex(32)}")
        appendLine("SYNAPSE_FORM_SECRET=${generateSecretHex(32)}")
        appendLine()

        // Mailu secret key
        appendLine("MAILU_SECRET_KEY=${generateSecretB64(16)}")
        appendLine()

        // Jellyfin OIDC
        appendLine("JELLYFIN_OIDC_SECRET=${generateSecretHex(32)}")
        appendLine()

        // Service tokens
        appendLine("LITELLM_MASTER_KEY=sk-${generateSecretHex(32)}")
        appendLine("BROWSERLESS_TOKEN=${generateSecretHex(32)}")
        appendLine("KOPIA_PASSWORD=${generatePassword(32)}")
        appendLine("QDRANT_API_KEY=${generateSecretHex(32)}")
        appendLine()

        // API keys (if provided externally, these remain empty)
        appendLine("HUGGINGFACEHUB_API_TOKEN=${env["HUGGINGFACEHUB_API_TOKEN"] ?: ""}")
    }

    logInfo("Encrypting secrets...")
    encryptSecrets(content)
    logInfo("✓ Secrets generated and encrypted successfully")
    logWarn("Keep the secrets directory secure: $SECRETS_DIR")
}

private fun cmdExport() {
    if (!Files.exists(SECRETS_FILE)) {
        logError("Secrets file not found. Run init first.")
        kotlin.system.exitProcess(1)
    }

    // Determine output path: project root .env file
    // SECRETS_DIR is typically ~/.local/share/stack-secrets or ./volumes/secrets
    // We want to write to the project root, so go up from SECRETS_DIR
    val projectRoot = if (SECRETS_DIR.toString().contains("/.local/share/")) {
        // If using ~/.local/share/stack-secrets, assume CWD is project root
        Path.of(System.getProperty("user.dir"))
    } else {
        // If using relative path like ./volumes/secrets, go up two levels
        SECRETS_DIR.parent?.parent ?: Path.of(".")
    }

    val envFile = projectRoot.resolve(".env")

    logInfo("Decrypting secrets...")
    var plaintextRaw = decryptSecrets()

    // Backfill: ensure newly introduced required secrets exist even if the
    // secrets were initialized before these keys were added to the generator.
    // If any are missing, generate them, re‑encrypt, and reload plaintext.
    fun parseToMap(text: String): MutableMap<String, String> {
        val map = linkedMapOf<String, String>()
        text.lines().forEach { line ->
            if (line.isBlank() || line.trimStart().startsWith("#") || !line.contains('=')) return@forEach
            val idx = line.indexOf('=')
            if (idx <= 0) return@forEach
            val key = line.substring(0, idx)
            val value = line.substring(idx + 1)
            map[key] = value
        }
        return map
    }

    val currentMap = parseToMap(plaintextRaw)

    var changed = false

    fun putIfMissing(key: String, supplier: () -> String) {
        if (!currentMap.containsKey(key)) {
            currentMap[key] = supplier()
            logWarn("Backfilled missing secret: $key")
            changed = true
        }
    }

    // Mastodon related secrets introduced later
    val mastodonSmtpUserBackfill = env["MASTODON_SMTP_USER"] ?: "mastodon@${MAIL_DOMAIN}"
    putIfMissing("MASTODON_DB_PASSWORD") { generatePassword(32) }
    putIfMissing("MASTODON_SECRET_KEY_BASE") { generateSecretHex(64) }
    putIfMissing("MASTODON_OTP_SECRET") { generateSecretHex(64) }
    putIfMissing("MASTODON_ENCRYPTION_DETERMINISTIC_KEY") { generateSecretHex(32) }
    putIfMissing("MASTODON_ENCRYPTION_KEY_DERIVATION_SALT") { generateSecretHex(32) }
    putIfMissing("MASTODON_ENCRYPTION_PRIMARY_KEY") { generateSecretHex(32) }
    putIfMissing("MASTODON_SMTP_USER") { mastodonSmtpUserBackfill }
    putIfMissing("MASTODON_SMTP_PASSWORD") { generatePassword(24) }
    // Secret for BookStack database user
    putIfMissing("BOOKSTACK_DB_PASSWORD") { generatePassword(32) }
    putIfMissing("MASTODON_OIDC_SECRET") { generateSecretHex(48) }
    putIfMissing("VAPID_PRIVATE_KEY") { generateSecretB64(64) }
    putIfMissing("VAPID_PUBLIC_KEY") { generateSecretB64(64) }

    // Additional DB passwords
    putIfMissing("AUTHELIA_DB_PASSWORD") { generatePassword(32) }
    putIfMissing("GRAFANA_DB_PASSWORD") { generatePassword(32) }
    putIfMissing("VAULTWARDEN_DB_PASSWORD") { generatePassword(32) }
    putIfMissing("OPENWEBUI_DB_PASSWORD") { generatePassword(32) }

    // URL-encoded versions of passwords for connection strings
    if (currentMap.containsKey("OPENWEBUI_DB_PASSWORD") && !currentMap.containsKey("OPENWEBUI_DB_PASSWORD_ENCODED")) {
        currentMap["OPENWEBUI_DB_PASSWORD_ENCODED"] = urlEncode(currentMap["OPENWEBUI_DB_PASSWORD"]!!)
        logWarn("Backfilled missing secret: OPENWEBUI_DB_PASSWORD_ENCODED")
        changed = true
    }

    // Synapse secrets
    putIfMissing("SYNAPSE_DB_PASSWORD") { generatePassword(32) }
    putIfMissing("SYNAPSE_REGISTRATION_SECRET") { generateSecretHex(32) }
    putIfMissing("SYNAPSE_MACAROON_SECRET") { generateSecretHex(32) }
    putIfMissing("SYNAPSE_FORM_SECRET") { generateSecretHex(32) }

    // Mailu secrets
    putIfMissing("MAILU_DB_PASSWORD") { generatePassword(32) }
    putIfMissing("MAILU_SECRET_KEY") { generateSecretB64(16) }

    // Jellyfin
    putIfMissing("JELLYFIN_OIDC_SECRET") { generateSecretHex(32) }

    // Additional OAuth secrets
    putIfMissing("HOMEASSISTANT_OAUTH_SECRET") { generateSecretHex(32) }
    putIfMissing("DIM_OAUTH_SECRET") { generateSecretHex(32) }

    // BookStack APP_KEY
    putIfMissing("BOOKSTACK_APP_KEY") { "base64:${generateSecretB64(32)}" }

    // Seafile secrets
    putIfMissing("MARIADB_SEAFILE_ROOT_PASSWORD") { generatePassword(32) }
    putIfMissing("MARIADB_SEAFILE_PASSWORD") { generatePassword(32) }
    putIfMissing("SEAFILE_JWT_KEY") { generateSecretHex(32) }
    putIfMissing("SEAFILE_SECRET_KEY") { generateSecretHex(50) }
    putIfMissing("SEAFILE_EMAIL_PASSWORD") { generatePassword(32) }

    // Decode OIDC private key for template processing (if missing)
    if (currentMap.containsKey("AUTHELIA_IDENTITY_PROVIDERS_OIDC_ISSUER_PRIVATE_KEY") && !currentMap.containsKey("OIDC_PRIVATE_KEY")) {
        val rsaKeyB64 = currentMap["AUTHELIA_IDENTITY_PROVIDERS_OIDC_ISSUER_PRIVATE_KEY"]!!
        val rsaKeyPem = String(Base64.getDecoder().decode(rsaKeyB64), StandardCharsets.UTF_8)
        // Don't add extra indentation - YAML literal block (|) handles it
        currentMap["OIDC_PRIVATE_KEY"] = "\"${rsaKeyPem.trim()}\""
        logWarn("Backfilled missing secret: OIDC_PRIVATE_KEY")
        changed = true
    }

    // OIDC hash placeholders (will be filled by generate-oidc-hashes script)
    putIfMissing("GRAFANA_OAUTH_SECRET_HASH") { "PENDING" }
    putIfMissing("VAULTWARDEN_OAUTH_SECRET_HASH") { "PENDING" }
    putIfMissing("PLANKA_OAUTH_SECRET_HASH") { "PENDING" }
    putIfMissing("JUPYTERHUB_OAUTH_SECRET_HASH") { "PENDING" }
    putIfMissing("OPENWEBUI_OAUTH_SECRET_HASH") { "PENDING" }
    putIfMissing("PGADMIN_OAUTH_SECRET_HASH") { "PENDING" }
    putIfMissing("NEXTCLOUD_OAUTH_SECRET_HASH") { "PENDING" }
    putIfMissing("HOMEASSISTANT_OAUTH_SECRET_HASH") { "PENDING" }
    putIfMissing("DIM_OAUTH_SECRET_HASH") { "PENDING" }
    putIfMissing("MASTODON_OAUTH_SECRET_HASH") { "PENDING" }

    if (changed) {
        // Rebuild plaintext in the original order as much as possible.
        // We'll append any newly added keys at the end under a backfill note.
        val originalLines = plaintextRaw.lines().toMutableList()
        val existingKeys = originalLines.mapNotNull { line ->
            val i = line.indexOf('='); if (i > 0 && !line.trimStart().startsWith("#")) line.substring(0, i) else null
        }.toMutableSet()

        val builder = StringBuilder()
        builder.append(plaintextRaw)
        if (!plaintextRaw.endsWith("\n")) builder.append('\n')
        builder.appendLine("# --- Backfilled keys (auto-generated by export) ---")
        for ((k, v) in currentMap) {
            if (!existingKeys.contains(k)) {
                builder.appendLine("$k=$v")
            }
        }
        val updatedPlain = builder.toString()
        encryptSecrets(updatedPlain)
        plaintextRaw = decryptSecrets()
        logInfo("Secrets file updated with missing keys.")
    }

    // Escape values that contain '$' to prevent docker compose from treating them as env interpolation
    // We only transform lines in KEY=VALUE format that are not comments
    val plaintext = buildString {
        for (line in plaintextRaw.lines()) {
            if (line.isBlank() || line.trimStart().startsWith("#") || !line.contains("=")) {
                appendLine(line)
            } else {
                val idx = line.indexOf('=')
                if (idx <= 0) {
                    appendLine(line)
                } else {
                    val key = line.substring(0, idx)
                    val value = line.substring(idx + 1)
                    val escaped = value.replace("$", "$$")
                    appendLine("$key=$escaped")
                }
            }
        }
    }

    logInfo("Writing to ${envFile.toAbsolutePath()}")
    val header = buildConfigHeader()
    val combined = buildString {
        append(header)
        // Ensure there is exactly one blank line separating header and secrets block
        if (!header.endsWith("\n\n")) append('\n')
        append(plaintext)
    }
    Files.writeString(envFile, combined, StandardCharsets.UTF_8)
    setPerm600(envFile)

    logInfo("✓ Secrets exported to .env")
    logWarn("DO NOT commit .env to version control!")
    logInfo("Load with: export \$(cat .env | xargs)")
}

private fun cmdRotate(secretName: String) {
    logInfo("Rotating secret: $secretName")
    val plain = decryptSecrets()
    val lines = plain.lines().toMutableList()

    val newValue = when {
        secretName.endsWith("_PASSWORD") || secretName.endsWith("_ADMIN_TOKEN") || secretName == "KOPIA_PASSWORD" -> generatePassword(32)
        secretName.endsWith("_RSA_KEY") || secretName.endsWith("_PRIVATE_KEY") -> generateRsaKeyBase64()
        secretName == "LITELLM_MASTER_KEY" -> "sk-" + generateSecretHex(32)
        else -> generateSecretHex(32)
    }

    var replaced = false
    for (i in lines.indices) {
        if (lines[i].startsWith("$secretName=")) {
            lines[i] = "$secretName=$newValue"
            replaced = true
            break
        }
    }

    if (!replaced) {
        logWarn("Secret name not found in secrets file; no changes made: $secretName")
        return
    }

    val updated = lines.joinToString("\n") + if (plain.endsWith("\n")) "\n" else ""
    encryptSecrets(updated)
    logInfo("✓ Secret rotated: $secretName")
    logWarn("Services using this secret must be restarted")
}

// ---------- Main ----------
when (val cmd = args.getOrNull(0)) {
    "init" -> cmdInit()
    "export" -> cmdExport()
    "rotate" -> {
        val name = args.getOrNull(1)
        if (name.isNullOrBlank()) {
            logError("Usage: configure-environment.kts rotate SECRET_NAME")
            kotlin.system.exitProcess(1)
        }
        cmdRotate(name)
    }
    else -> {
        println("Usage: configure-environment.kts {init|export|rotate SECRET_NAME}")
        println()
        println("Commands:")
        println("  init     - Generate and encrypt all secrets (first run only)")
        println("  export   - Decrypt and export secrets as environment variables")
        println("  rotate   - Rotate a specific secret value")
        kotlin.system.exitProcess(1)
    }
}
