package org.datamancy.pipeline.sinks

import com.google.gson.Gson
import com.google.gson.JsonParser
import io.github.oshai.kotlinlogging.KotlinLogging
import okhttp3.MediaType.Companion.toMediaType
import okhttp3.OkHttpClient
import okhttp3.Request
import okhttp3.RequestBody.Companion.toRequestBody
import org.datamancy.pipeline.core.Sink
import java.util.concurrent.TimeUnit

private val logger = KotlinLogging.logger {}

/**
 * Writes content to BookStack wiki via REST API
 * Creates books, chapters, and pages organized by content type
 */
class BookStackSink(
    private val bookstackUrl: String,
    private val tokenId: String,
    private val tokenSecret: String
) : Sink<BookStackDocument> {
    override val name = "BookStackSink"

    private val client = OkHttpClient.Builder()
        .connectTimeout(30, TimeUnit.SECONDS)
        .writeTimeout(30, TimeUnit.SECONDS)
        .readTimeout(30, TimeUnit.SECONDS)
        .build()

    private val gson = Gson()
    private val jsonMediaType = "application/json".toMediaType()

    // Cache book/chapter/page IDs to avoid repeated lookups
    private val bookCache = mutableMapOf<String, Int>()
    private val chapterCache = mutableMapOf<String, Int>()
    private val pageCache = mutableMapOf<String, Int>() // Cache: "bookId:chapterId:pageTitle" -> pageId

    // Store last written page URL (thread-safe for concurrent writes)
    private val lastPageUrlMap = java.util.concurrent.ConcurrentHashMap<String, String>()

    /**
     * Write a document to BookStack and return the page URL
     * The URL is stored in a thread-safe map that can be retrieved via getLastPageUrl()
     */
    override suspend fun write(item: BookStackDocument) {
        try {
            // Ensure book exists
            val bookId = getOrCreateBook(item.bookName, item.bookDescription)

            // Ensure chapter exists (if specified)
            val chapterId = if (item.chapterName != null) {
                getOrCreateChapter(bookId, item.chapterName, item.chapterDescription)
            } else null

            // Create or update page and get URL
            val pageUrl = createOrUpdatePage(bookId, chapterId, item)

            // Store the URL for retrieval
            lastPageUrlMap[item.pageTitle] = pageUrl

            logger.debug { "Wrote page '${item.pageTitle}' to BookStack: $pageUrl" }
        } catch (e: Exception) {
            logger.error(e) { "Failed to write to BookStack: ${e.message}" }
            throw e
        }
    }

    override suspend fun writeBatch(items: List<BookStackDocument>) {
        items.forEach { write(it) }
    }

    /**
     * Get the URL of the last written page for a given title
     * Returns null if the page hasn't been written yet
     */
    fun getLastPageUrl(pageTitle: String): String? {
        return lastPageUrlMap[pageTitle]
    }

    override suspend fun healthCheck(): Boolean {
        return try {
            val request = Request.Builder()
                .url("$bookstackUrl/api/books")
                .header("Authorization", "Token $tokenId:$tokenSecret")
                .get()
                .build()

            client.newCall(request).execute().use { response ->
                response.isSuccessful
            }
        } catch (e: Exception) {
            logger.error(e) { "BookStack health check failed: ${e.message}" }
            false
        }
    }

    private fun getOrCreateBook(name: String, description: String?): Int {
        // Check cache
        bookCache[name]?.let { return it }

        // Search for existing book
        try {
            val searchRequest = Request.Builder()
                .url("$bookstackUrl/api/books")
                .header("Authorization", "Token $tokenId:$tokenSecret")
                .get()
                .build()

            client.newCall(searchRequest).execute().use { response ->
                if (response.isSuccessful) {
                    val bodyString = response.body?.string() ?: return@use
                    val json = JsonParser.parseString(bodyString).asJsonObject
                    val books = json.getAsJsonArray("data")

                    for (book in books) {
                        val bookObj = book.asJsonObject
                        if (bookObj.get("name").asString == name) {
                            val id = bookObj.get("id").asInt
                            bookCache[name] = id
                            return id
                        }
                    }
                }
            }
        } catch (e: Exception) {
            logger.warn(e) { "Failed to search for book: ${e.message}" }
        }

        // Create new book
        val payload = mapOf(
            "name" to name,
            "description" to (description ?: "Auto-generated by Datamancy Pipeline")
        )

        val request = Request.Builder()
            .url("$bookstackUrl/api/books")
            .header("Authorization", "Token $tokenId:$tokenSecret")
            .post(gson.toJson(payload).toRequestBody(jsonMediaType))
            .build()

        client.newCall(request).execute().use { response ->
            val bodyString = response.body?.string() ?: throw Exception("Empty response body")

            if (!response.isSuccessful) {
                throw Exception("Failed to create book: ${response.code} $bodyString")
            }

            val json = JsonParser.parseString(bodyString).asJsonObject
            val id = json.get("id").asInt
            bookCache[name] = id
            logger.info { "Created BookStack book: $name (ID: $id)" }
            return id
        }
    }

    private fun getOrCreateChapter(bookId: Int, name: String, description: String?): Int {
        val cacheKey = "$bookId:$name"
        chapterCache[cacheKey]?.let { return it }

        // Search for existing chapter in book
        try {
            val searchRequest = Request.Builder()
                .url("$bookstackUrl/api/books/$bookId")
                .header("Authorization", "Token $tokenId:$tokenSecret")
                .get()
                .build()

            client.newCall(searchRequest).execute().use { response ->
                if (response.isSuccessful) {
                    val bodyString = response.body?.string() ?: return@use
                    val json = JsonParser.parseString(bodyString).asJsonObject
                    val contents = json.getAsJsonArray("contents")

                    for (content in contents) {
                        val contentObj = content.asJsonObject
                        if (contentObj.get("type").asString == "chapter" &&
                            contentObj.get("name").asString == name) {
                            val id = contentObj.get("id").asInt
                            chapterCache[cacheKey] = id
                            return id
                        }
                    }
                }
            }
        } catch (e: Exception) {
            logger.warn(e) { "Failed to search for chapter: ${e.message}" }
        }

        // Create new chapter
        val payload = mapOf(
            "book_id" to bookId,
            "name" to name,
            "description" to (description ?: "")
        )

        val request = Request.Builder()
            .url("$bookstackUrl/api/chapters")
            .header("Authorization", "Token $tokenId:$tokenSecret")
            .post(gson.toJson(payload).toRequestBody(jsonMediaType))
            .build()

        client.newCall(request).execute().use { response ->
            val bodyString = response.body?.string() ?: throw Exception("Empty response body")

            if (!response.isSuccessful) {
                throw Exception("Failed to create chapter: ${response.code} $bodyString")
            }

            val json = JsonParser.parseString(bodyString).asJsonObject
            val id = json.get("id").asInt
            chapterCache[cacheKey] = id
            logger.info { "Created BookStack chapter: $name (ID: $id)" }
            return id
        }
    }

    private fun createOrUpdatePage(bookId: Int, chapterId: Int?, doc: BookStackDocument): String {
        // Check cache first
        val cacheKey = "${bookId}:${chapterId ?: "null"}:${doc.pageTitle}"
        var existingPageId: Int? = pageCache[cacheKey]

        // If not in cache, search for existing page
        if (existingPageId == null) {
            try {
                val searchRequest = Request.Builder()
                    .url("$bookstackUrl/api/pages?filter[name]=${doc.pageTitle}")
                    .header("Authorization", "Token $tokenId:$tokenSecret")
                    .get()
                    .build()

                client.newCall(searchRequest).execute().use { response ->
                    if (response.isSuccessful) {
                        val bodyString = response.body?.string() ?: return@use
                        val json = JsonParser.parseString(bodyString).asJsonObject
                        val pages = json.getAsJsonArray("data")

                        for (page in pages) {
                            val pageObj = page.asJsonObject
                            // Check if page is in the same book/chapter
                            val pageBookId = pageObj.get("book_id").asInt
                            val pageChapterId = pageObj.get("chapter_id")?.let {
                                if (it.isJsonNull) null else it.asInt
                            }

                            if (pageBookId == bookId && pageChapterId == chapterId) {
                                existingPageId = pageObj.get("id").asInt
                                pageCache[cacheKey] = existingPageId!!
                                break
                            }
                        }
                    }
                }
            } catch (e: Exception) {
                logger.warn(e) { "Failed to search for existing page: ${e.message}" }
            }
        }

        val payload = mutableMapOf(
            "book_id" to bookId,
            "name" to doc.pageTitle,
            "html" to doc.pageContent,
            "tags" to doc.tags.map { tag ->
                mapOf("name" to tag.key, "value" to tag.value)
            }
        )

        if (chapterId != null) {
            payload["chapter_id"] = chapterId
        }

        if (existingPageId != null) {
            // Update existing page
            val request = Request.Builder()
                .url("$bookstackUrl/api/pages/$existingPageId")
                .header("Authorization", "Token $tokenId:$tokenSecret")
                .put(gson.toJson(payload).toRequestBody(jsonMediaType))
                .build()

            client.newCall(request).execute().use { response ->
                val bodyString = response.body?.string() ?: throw Exception("Empty response body")

                if (!response.isSuccessful) {
                    throw Exception("Failed to update page: ${response.code} $bodyString")
                }

                val json = JsonParser.parseString(bodyString).asJsonObject
                val slug = json.get("slug")?.asString ?: throw Exception("No slug in response")
                val pageUrl = "$bookstackUrl/books/${json.get("book_slug")?.asString}/page/$slug"

                logger.debug { "Updated BookStack page: ${doc.pageTitle} (ID: $existingPageId)" }
                return pageUrl
            }
        } else {
            // Create new page
            val request = Request.Builder()
                .url("$bookstackUrl/api/pages")
                .header("Authorization", "Token $tokenId:$tokenSecret")
                .post(gson.toJson(payload).toRequestBody(jsonMediaType))
                .build()

            client.newCall(request).execute().use { response ->
                val bodyString = response.body?.string() ?: throw Exception("Empty response body")

                if (!response.isSuccessful) {
                    throw Exception("Failed to create page: ${response.code} $bodyString")
                }

                val json = JsonParser.parseString(bodyString).asJsonObject
                val pageId = json.get("id").asInt
                val slug = json.get("slug")?.asString ?: throw Exception("No slug in response")
                val pageUrl = "$bookstackUrl/books/${json.get("book_slug")?.asString}/page/$slug"

                // Cache the newly created page ID
                pageCache[cacheKey] = pageId

                logger.debug { "Created BookStack page: ${doc.pageTitle} (ID: $pageId)" }
                return pageUrl
            }
        }
    }
}

data class BookStackDocument(
    val bookName: String,
    val bookDescription: String? = null,
    val chapterName: String? = null,
    val chapterDescription: String? = null,
    val pageTitle: String,
    val pageContent: String,  // HTML format
    val tags: Map<String, String> = emptyMap()
)
