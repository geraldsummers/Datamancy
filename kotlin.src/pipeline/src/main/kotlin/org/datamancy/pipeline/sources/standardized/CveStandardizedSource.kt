package org.datamancy.pipeline.sources.standardized

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import org.datamancy.pipeline.core.Chunkable
import org.datamancy.pipeline.core.StandardizedSource
import org.datamancy.pipeline.processors.Chunker
import org.datamancy.pipeline.scheduling.BackfillStrategy
import org.datamancy.pipeline.scheduling.ResyncStrategy
import org.datamancy.pipeline.scheduling.RunMetadata
import org.datamancy.pipeline.scheduling.RunType
import org.datamancy.pipeline.sinks.BookStackDocument
import org.datamancy.pipeline.sources.CveEntry
import org.datamancy.pipeline.sources.CveSource


data class CveChunkable(val entry: CveEntry) : Chunkable {
    override fun toText(): String = entry.toText()
    override fun getId(): String = entry.cveId
    override fun getMetadata(): Map<String, String> = mapOf(
        "severity" to entry.severity,
        "cvssScore" to (entry.baseScore?.toString() ?: "unknown"),
        "publishedDate" to entry.publishedDate,
        "lastModifiedDate" to entry.lastModifiedDate,
        "affectedProductsCount" to entry.affectedProducts.size.toString()
    )

    fun toBookStackDocument(): BookStackDocument {
        val severityColor = when (entry.severity.uppercase()) {
            "CRITICAL" -> "#dc3545"
            "HIGH" -> "#fd7e14"
            "MEDIUM" -> "#ffc107"
            "LOW" -> "#28a745"
            else -> "#6c757d"
        }

        return BookStackDocument(
            bookName = "CVE Database",
            bookDescription = "Security vulnerabilities from the National Vulnerability Database (NVD)",
            chapterName = entry.severity,
            chapterDescription = "${entry.severity} severity vulnerabilities",
            pageTitle = entry.cveId,
            pageContent = """
                <h1>${entry.cveId}</h1>
                <div style="margin-bottom: 20px; padding: 15px; background-color: #f8f9fa; border-left: 5px solid $severityColor;">
                    <p><strong style="color: $severityColor;">Severity:</strong> ${entry.severity}${entry.baseScore?.let { " (CVSS Score: $it)" } ?: ""}</p>
                    ${entry.vectorString?.let { "<p><strong>CVSS Vector:</strong> <code>$it</code></p>" } ?: ""}
                    <p><strong>Published:</strong> ${entry.publishedDate}</p>
                    <p><strong>Last Modified:</strong> ${entry.lastModifiedDate}</p>
                </div>
                <div style="margin-top: 20px;">
                    <h2>Description</h2>
                    <p>${entry.description}</p>
                </div>
                ${if (entry.affectedProducts.isNotEmpty()) """
                <div style="margin-top: 20px;">
                    <h2>Affected Products</h2>
                    <ul>
                        ${entry.affectedProducts.take(50).joinToString("\n") { "<li>$it</li>" }}
                        ${if (entry.affectedProducts.size > 50) "<li><em>... and ${entry.affectedProducts.size - 50} more</em></li>" else ""}
                    </ul>
                </div>
                """ else ""}
                ${if (entry.references.isNotEmpty()) """
                <div style="margin-top: 20px;">
                    <h2>References</h2>
                    <ul>
                        ${entry.references.take(20).joinToString("\n") { "<li><a href=\"$it\" target=\"_blank\">$it</a></li>" }}
                        ${if (entry.references.size > 20) "<li><em>... and ${entry.references.size - 20} more</em></li>" else ""}
                    </ul>
                </div>
                """ else ""}
                <hr>
                <p style="font-size: 0.9em; color: #666;">
                    <em>This page was automatically generated by Datamancy Pipeline from NVD CVE database</em>
                </p>
            """.trimIndent(),
            tags = mapOf(
                "source" to "cve",
                "severity" to entry.severity,
                "cvss_score" to (entry.baseScore?.toString() ?: "unknown"),
                "published" to entry.publishedDate,
                "cve_id" to entry.cveId
            )
        )
    }
}


class CveStandardizedSource(
    private val apiKey: String? = null,
    private val maxResults: Int = Int.MAX_VALUE
) : StandardizedSource<CveChunkable> {
    override val name = "cve"

    override fun resyncStrategy() = ResyncStrategy.DailyAt(hour = 1, minute = 0)

    override fun backfillStrategy() = BackfillStrategy.CveDatabase(modifiedSinceLastRun = true)

    override fun needsChunking() = true

    override fun chunker() = Chunker.forEmbeddingModel(tokenLimit = 8192, overlapPercent = 0.20)

    override suspend fun fetchForRun(metadata: RunMetadata): Flow<CveChunkable> {
        
        
        

        val source = when (metadata.runType) {
            RunType.INITIAL_PULL -> {
                
                CveSource(apiKey = apiKey, maxResults = 10000)
            }
            RunType.RESYNC -> {
                
                
                CveSource(apiKey = apiKey, maxResults = 1000)
            }
        }

        return source.fetch().map { CveChunkable(it) }
    }
}
