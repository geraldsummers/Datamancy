package org.datamancy.pipeline.sources.standardized

import kotlinx.coroutines.flow.Flow
import kotlinx.coroutines.flow.map
import org.datamancy.pipeline.core.Chunkable
import org.datamancy.pipeline.core.StandardizedSource
import org.datamancy.pipeline.processors.Chunker
import org.datamancy.pipeline.scheduling.BackfillStrategy
import org.datamancy.pipeline.scheduling.ResyncStrategy
import org.datamancy.pipeline.scheduling.RunMetadata
import org.datamancy.pipeline.scheduling.RunType
import org.datamancy.pipeline.sinks.BookStackDocument
import org.datamancy.pipeline.sources.WikiPage
import org.datamancy.pipeline.sources.WikiSource


data class WikiPageChunkable(val page: WikiPage) : Chunkable {
    override fun toText(): String = page.toText()
    override fun getId(): String = page.id
    override fun getMetadata(): Map<String, String> = mapOf(
        "title" to page.title,
        "wikiType" to page.wikiType,
        "url" to page.url,
        "categories" to page.categories.joinToString(", ")
    )

    fun toBookStackDocument(): BookStackDocument {
        val wikiColor = when (page.wikiType) {
            "debian" -> "#D70A53"
            "arch" -> "#1793D1"
            else -> "#007bff"
        }

        val wikiName = when (page.wikiType) {
            "debian" -> "Debian Wiki"
            "arch" -> "Arch Wiki"
            else -> "${page.wikiType.replaceFirstChar { it.uppercase() }} Wiki"
        }

        return BookStackDocument(
            bookName = wikiName,
            bookDescription = "Community-maintained documentation for $wikiName",
            chapterName = if (page.categories.isNotEmpty()) page.categories.first() else null,
            chapterDescription = if (page.categories.isNotEmpty()) "Pages in ${page.categories.first()} category" else null,
            pageTitle = page.title,
            pageContent = """
                <h1>${page.title}</h1>
                <div style="margin-bottom: 20px; padding: 15px; background-color: #f8f9fa; border-left: 4px solid $wikiColor;">
                    <p><strong>Wiki:</strong> <span style="color: $wikiColor; font-weight: bold;">$wikiName</span></p>
                    <p><strong>URL:</strong> <a href="${page.url}" target="_blank">${page.url}</a></p>
                    ${if (page.categories.isNotEmpty()) "<p><strong>Categories:</strong> ${page.categories.joinToString(", ")}</p>" else ""}
                </div>
                <div style="margin-top: 20px;">
                    <h2>Content</h2>
                    <div style="white-space: pre-wrap; word-wrap: break-word; line-height: 1.6;">
                        ${page.content.split("\n\n").joinToString("\n") { para ->
                            if (para.isNotBlank()) "<p>${para.replace("\n", " ")}</p>" else ""
                        }}
                    </div>
                </div>
                <hr>
                <p style="font-size: 0.9em; color: #666;">
                    <em>This page was automatically generated by Datamancy Pipeline from $wikiName at <a href="${page.url}" target="_blank">${page.url}</a></em>
                </p>
            """.trimIndent(),
            tags = mapOf(
                "source" to "wiki",
                "wiki_type" to page.wikiType,
                "categories" to page.categories.joinToString(",")
            )
        )
    }
}


class DebianWikiStandardizedSource(
    private val maxPages: Int = 500,
    private val categories: List<String> = emptyList()
) : StandardizedSource<WikiPageChunkable> {
    override val name = "debian_wiki"

    override fun resyncStrategy() = ResyncStrategy.DailyAt(hour = 4, minute = 0)

    override fun backfillStrategy() = BackfillStrategy.WikiDumpAndWatch(
        dumpUrl = "https://wiki.debian.org/RecentChanges",
        recentChangesLimit = 500
    )

    override fun needsChunking() = true

    override fun chunker() = Chunker.forEmbeddingModel(tokenLimit = 8192, overlapPercent = 0.20)

    override suspend fun fetchForRun(metadata: RunMetadata): Flow<WikiPageChunkable> {
        
        
        

        val pageLimit = when (metadata.runType) {
            RunType.INITIAL_PULL -> maxPages
            RunType.RESYNC -> 100  
        }

        val source = WikiSource(
            wikiType = WikiSource.WikiType.DEBIAN,
            maxPages = pageLimit,
            categories = categories
        )

        return source.fetch().map { WikiPageChunkable(it) }
    }
}
